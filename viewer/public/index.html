<!DOCTYPE html>

<style>

body {
  font: 10px sans-serif;
}

.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.x.axis path {
  display: none;
}

.line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.focus circle {
  fill: none;
  stroke: steelblue;
}

.focus box {
  display: block;
  width: 100px;
  height: 100px;
  background:red;
}

</style>

<select onchange="if (this.selectedIndex) renderGraph(this.value);">
  <option index=-1>Please Select a Trial</option>
  {{range .}}
  <option value="{{.}}">{{.}}</option>
  {{end}}
</select>

<body>

  <div id="svg"></div>
</body>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>

var renderGraph = function(path) {

var margin = {top: 20, right: 50, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom,
    bisectTimestamp = d3.bisector(function(d) { return d.timestamp; }).left;

var x = d3.scaleLinear()
    .rangeRound([0, width]);

var y = d3.scaleLinear()
    .rangeRound([height, 0]);

var line = d3.line()
    .x(function(d) { return  x(d.timestamp); })
    .y(function(d) { return y(d.code); });

//d3.select("div#svg").select("svg").remove();

var g = d3.select("div#svg").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var drawBoshEvent = function(data) {
 for (i in data){
   if (data[i].annotation) {
       g.append("circle")
        .attr("r", 4).attr("transform", "translate(" + x(data[i].timestamp) + "," + y(data[i].code) + ")");
   }
 }
}

var firstTimestamp = null;

var getDownTime = function(data){
  var first = null;
  var last = null;
  for (var i = 0; i < data.length; i++) {
    if(data[i].code != 200) {
      if(first == null) {
        first = data[i].timestamp;
      }
      last = data[i].timestamp;
      console.log(last)
    }
  }
  console.log(last);
  return {start: x(first), end: x(last)};
}

d3.csv(path, function(d) {
  if (firstTimestamp == null) {
    firstTimestamp = Number(d.timestamp);
  }
  var newData = { timestamp: ( Number(d.timestamp) - firstTimestamp), code: d.code, annotation: d.annotation}
  return newData;

}, function(error, data) {
  if (error) throw error;

  console.log(data);

  x.domain(d3.extent(data, function(d) { return d.timestamp; }));
  y.domain(d3.extent(data, function(d) { return d.code }));

  var downtimeX = getDownTime(data);
console.log(downtimeX)
  g.append("rect")
    .attr("width", downtimeX.end-downtimeX.start)
    .attr("height", "100%")
    .attr("fill", "pink")
    .attr("transform", "translate(" + downtimeX.start + "," + 0 + ")"); ;

  g.append("g")
      .attr("transform", "translate(0," + height + ")")
      .call(d3.axisBottom(x))
    .select(".domain");

  g.append("g")
      .call(d3.axisLeft(y))
    .append("text")
      .attr("fill", "#000")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", "0.71em")
      .attr("text-anchor", "end")
      .text("success");

  g.append("path")
      .datum(data)
      .attr("fill", "none")
      .attr("stroke", "steelblue")
      .attr("stroke-linejoin", "round")
      .attr("stroke-linecap", "round")
      .attr("stroke-width", 1.5)
      .attr("d", line);

  drawBoshEvent(data);



  var focus = g.append("g")
      .attr("class", "focus")
      .style("display", "none");

  focus.append("circle")
      .attr("r", 4.5);

  focus.append("text")
      .attr("x", 9)
      .attr("dy", ".75em");



  g.append("rect")
      .attr("class", "overlay")
      .attr("width", width)
      .attr("height", height)
      .on("mouseover", function() { focus.style("display", null); })
      .on("mouseout", function() { focus.style("display", "none"); })
      .on("mousemove", mousemove);

    var getAnnotationObjectWithInRange = function (data, i){
      var range = 30;
      //TODO: CHECK FOR OUT OF BOUNDS
      for (j = i - range; j < i + range; j++) {
        if (data[j].annotation) {
          return data[j];
        }
      }
      return null
    }


    function mousemove() {
      var x0 = x.invert(d3.mouse(this)[0]),
          i = bisectTimestamp(data, x0, 1),

          d0 = data[i - 1],
          d1 = data[i],
          d = x0 - d0.timestamp > d1.timestamp - x0 ? d1 : d0;

          annotationNode = getAnnotationObjectWithInRange(data, i);
          if(annotationNode) {
            d = annotationNode;
          }

          focus.attr("transform", "translate(" + x(d.timestamp) + "," + y(d.code) + ")");
          focus.selectAll("text").remove();
          var annotations = d.annotation.split('\n');
          for (b in annotations) {
            var annotation = annotations[b];
            focus.append("text").text(annotation).attr("x", 9).attr("dy", (15*(b) + 15) + "px");
          }
    }
});
}

</script>


